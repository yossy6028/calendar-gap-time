/**
 * „Ç´„É¨„É≥„ÉÄ„ÉºÁ©∫„ÅçÊôÇÈñìÊ§úÁ¥¢„Ç¢„Éó„É™ - „É°„Ç§„É≥„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
 * ÂÆåÂÖ®„É™„Éï„Ç°„ÇØ„Çø„É™„É≥„Ç∞ÁâàÔºö„É¢„Ç∏„É•„Éº„É´Âåñ„ÄÅ„Çª„Ç≠„É•„É™„ÉÜ„Ç£Âº∑Âåñ„ÄÅ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊîπÂñÑ
 */

import React, { useState, useCallback, useMemo } from 'react';
import {
  Container,
  Typography,
  Box,
  Card,
  CardContent,
  Button,
  Grid,
  Chip,
  IconButton,
  TextField,
  List,
  ListItem,
  ListItemText,
  Paper
} from '@mui/material';
import { styled } from '@mui/material/styles';
import dayjs from 'dayjs';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';
import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';
import 'dayjs/locale/ja';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { PickersDay } from '@mui/x-date-pickers/PickersDay';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import DeleteIcon from '@mui/icons-material/Delete';
import SearchIcon from '@mui/icons-material/Search';

// ÂÜÖÈÉ®„É¢„Ç∏„É•„Éº„É´„Ç§„É≥„Éù„Éº„Éà
import { 
  TIME_CONSTANTS,
  ERROR_MESSAGES,
  THEME_COLORS,
  getConfig
} from './config/constants.js';
import { Validator } from './utils/validation.js';
import Logger from './utils/logger.js';
import ApiService, { ApiError } from './services/apiService.js';

// dayjsÊó•Êú¨Ë™û„É≠„Ç±„Éº„É´Ë®≠ÂÆö
dayjs.locale('ja');
dayjs.extend(isSameOrBefore);
dayjs.extend(isSameOrAfter);

// „Çπ„Çø„Ç§„É´‰ªò„Åç„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
const StyledCard = styled(Card)(({ theme }) => ({
  background: THEME_COLORS.CARD_GRADIENT,
  backdropFilter: 'blur(10px)',
  borderRadius: 16,
  boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
  border: '1px solid rgba(255, 255, 255, 0.2)',
  transition: 'all 0.3s ease',
  '&:hover': {
    transform: 'translateY(-4px)',
    boxShadow: '0 12px 48px rgba(0, 0, 0, 0.15)',
  }
}));

const CalendarGrid = styled(Box)(({ theme }) => ({
  display: 'grid',
  gridTemplateColumns: 'repeat(7, 1fr)',
  gap: theme.spacing(1),
  marginTop: theme.spacing(2),
}));

const CalendarDay = styled(Paper)(({ theme, isSelected, isInRange, isToday }) => ({
  padding: theme.spacing(1),
  textAlign: 'center',
  cursor: 'pointer',
  minHeight: 40,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  borderRadius: 8,
  transition: 'all 0.2s ease',
  backgroundColor: isSelected 
    ? theme.palette.primary.main 
    : isInRange 
    ? theme.palette.primary.light 
    : isToday 
    ? theme.palette.secondary.light
    : theme.palette.background.paper,
  color: isSelected || isInRange 
    ? theme.palette.primary.contrastText 
    : isToday
    ? theme.palette.secondary.contrastText
    : theme.palette.text.primary,
  '&:hover': {
    backgroundColor: isSelected 
      ? theme.palette.primary.dark 
      : theme.palette.primary.light,
    color: theme.palette.primary.contrastText,
    transform: 'scale(1.05)',
  }
}));

/**
 * Êó•‰ªò„ÉªÊôÇÈñì„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ÔºàÊúÄÈÅ©ÂåñÁâàÔºâ
 */
const DateTimeUtils = {
  /**
   * Êó•‰ªòÁØÑÂõ≤ÁîüÊàêÔºà„É°„É¢ÂåñÂØæÂøúÔºâ
   */
  generateDateRange: (startDate, endDate) => {
    const dates = [];
    let currentDate = startDate.clone();
    
    while (currentDate.isBefore(endDate) || currentDate.isSame(endDate, 'day')) {
      dates.push(currentDate.clone());
      currentDate = currentDate.add(1, 'day');
    }
    
    return dates;
  },

  /**
   * ÈÄ£Á∂ö„Åô„ÇãÊôÇÈñì„Çπ„É≠„ÉÉ„Éà„ÅÆ„Éû„Éº„Ç∏ÔºàÊúÄÈÅ©ÂåñÁâàÔºâ
   */
  mergeContinuousSlots: (slots) => {
    if (!Array.isArray(slots) || slots.length === 0) return [];
    
    // „ÇΩ„Éº„Éà
    const sortedSlots = [...slots].sort((a, b) => 
      a.startTime.localeCompare(b.startTime)
    );
    
    const mergedSlots = [];
    let currentSlot = { ...sortedSlots[0] };
    
    for (let i = 1; i < sortedSlots.length; i++) {
      const prevEndTime = dayjs(`2000-01-01 ${currentSlot.endTime}`);
      const currentStartTime = dayjs(`2000-01-01 ${sortedSlots[i].startTime}`);
      
      // ÈÄ£Á∂ö„Åæ„Åü„ÅØÈáçË§á„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Éû„Éº„Ç∏
      if (prevEndTime.isSameOrAfter(currentStartTime)) {
        const currentEndTime = dayjs(`2000-01-01 ${currentSlot.endTime}`);
        const nextEndTime = dayjs(`2000-01-01 ${sortedSlots[i].endTime}`);
        
        currentSlot.endTime = currentEndTime.isAfter(nextEndTime) 
          ? currentSlot.endTime 
          : sortedSlots[i].endTime;
        currentSlot.isContinuous = true;
      } else {
        mergedSlots.push(currentSlot);
        currentSlot = { ...sortedSlots[i] };
      }
    }
    
    mergedSlots.push(currentSlot);
    return mergedSlots;
  },

  /**
   * „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÁµ±‰∏Ä
   */
  formatDate: (date) => date.format('YYYY-MM-DD'),
  formatDisplayDate: (date) => date.format('MÊúàDÊó•(ddd)'),
  parseDate: (dateString) => dayjs(dateString)
};

/**
 * „Ç´„É¨„É≥„ÉÄ„Éº„Çµ„Éº„Éì„ÇπÔºàRate LimitÂØæÂøúÁâàÔºâ
 */
const CalendarService = {
  /**
   * ÂÖ®„Ç´„É¨„É≥„ÉÄ„Éº„ÅÆ‰∫àÂÆö„ÇíÂèñÂæóÔºà„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Âº∑ÂåñÔºâ
   */
  async fetchAllCalendarEvents(accessToken, startDate, endDate) {
    Logger.startPerformanceTimer('calendar_fetch_all');
    
    try {
      Logger.info('Fetching calendar events', { 
        startDate: startDate.format('YYYY-MM-DD'),
        endDate: endDate.format('YYYY-MM-DD')
      });
      
      // „Ç´„É¨„É≥„ÉÄ„Éº‰∏ÄË¶ßÂèñÂæó
      const calendarsData = await ApiService.authenticatedRequest(
        'https://www.googleapis.com/calendar/v3/users/me/calendarList',
        accessToken
      );
      console.log('ÂèñÂæó„Ç´„É¨„É≥„ÉÄ„Éº‰∏ÄË¶ß:', calendarsData.items?.map(c => ({ id: c.id, summary: c.summary })));
      
      if (!calendarsData.items || calendarsData.items.length === 0) {
        Logger.warn('No calendars found');
        return [];
      }
      
      Logger.info(`Found ${calendarsData.items.length} calendars`);

      // ÂêÑ„Ç´„É¨„É≥„ÉÄ„Éº„Åã„Çâ‰∫àÂÆö„ÇíÂèñÂæóÔºà„Éê„ÉÉ„ÉÅÂá¶ÁêÜÔºâ
      const eventRequests = calendarsData.items.map(calendar => ({
        url: `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendar.id)}/events?` +
             `timeMin=${startDate.toISOString()}` +
             `&timeMax=${endDate.toISOString()}` +
             `&singleEvents=true` +
             `&orderBy=startTime` +
             `&maxResults=250`,
        options: {
          headers: { 'Authorization': `Bearer ${accessToken}` }
        }
      }));

      const results = await ApiService.batchRequest(eventRequests);
      
      // „Éá„Éê„ÉÉ„Ç∞: ÂêÑ„Ç´„É¨„É≥„ÉÄ„Éº„Åî„Å®„ÅÆ‰∫àÂÆö‰ª∂Êï∞„Éª„Ç®„É©„ÉºÂÜÖÂÆπ„ÇíÂá∫Âäõ
      results.forEach((result, idx) => {
        const cal = calendarsData.items[idx];
        if (result.error) {
          console.error(`„Ç´„É¨„É≥„ÉÄ„Éº: ${cal?.summary || cal?.id} „Åß„Ç®„É©„Éº`, result.error);
        } else {
          console.log(`„Ç´„É¨„É≥„ÉÄ„Éº: ${cal?.summary || cal?.id}, ‰∫àÂÆö‰ª∂Êï∞:`, result.items?.length, result.items?.map(e => e.summary));
        }
      });
      
      // ÊàêÂäü„Åó„Åü„É™„ÇØ„Ç®„Çπ„Éà„Åã„Çâ„Ç§„Éô„É≥„Éà„ÇíÊäΩÂá∫
      const allEvents = results
        .filter(result => !result.error)
        .flatMap(result => result.items || [])
        .filter(event => event.start && event.start.dateTime);
      
      const errorCount = results.filter(result => result.error).length;
      if (errorCount > 0) {
        Logger.warn(`${errorCount} calendar requests failed`);
      }
      
      Logger.endPerformanceTimer('calendar_fetch_all');
      Logger.info(`Total events fetched: ${allEvents.length}`);
      
      return allEvents;
      
    } catch (error) {
      Logger.endPerformanceTimer('calendar_fetch_all');
      
      if (error instanceof ApiError && error.isRateLimited()) {
        throw new Error(`${ERROR_MESSAGES.RATE_LIMIT_EXCEEDED}\n\n‚è±Ô∏è Google Calendar API„ÅÆ‰ΩøÁî®Âà∂Èôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ\nüìÖ „Åó„Å∞„Çâ„ÅèÊôÇÈñì„Çí„Åä„ÅÑ„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`);
      }
      
      Logger.error('Failed to fetch calendar events', error);
      throw new Error(`${ERROR_MESSAGES.CALENDAR_FETCH_FAILED}: ${error.message}`);
    }
  },

  /**
   * Á©∫„ÅçÊôÇÈñìË®àÁÆóÔºàÂ∏åÊúõÊôÇÈñìÂ∏Ø„Éô„Éº„ÇπÂØæÂøúÔºâ
   */
  calculateAvailableSlots(events, startDate, endDate, timeSlots) {
    Logger.startPerformanceTimer('calculate_slots');
    try {
      let dates;
      if (timeSlots.length > 0) {
        // Â∏åÊúõÊôÇÈñìÂ∏Ø„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åù„ÅÆÊó•‰ªò„Å†„Åë
        const uniqueDates = [...new Set(timeSlots.map(slot => slot.date))];
        dates = uniqueDates.map(dateStr => dayjs(dateStr));
      } else {
        // Â∏åÊúõÊôÇÈñìÂ∏Ø„Åå„Å™„Åë„Çå„Å∞Â∏åÊúõÊúüÈñìÂÖ®‰Ωì
        dates = DateTimeUtils.generateDateRange(startDate, endDate);
      }
      const availableSlots = [];
      dates.forEach(date => {
        const dateStr = date.format('YYYY-MM-DD');
        const slotsForDate = timeSlots.filter(slot => slot.date === dateStr);
        const daySlots = this.calculateDayAvailableSlots(events, date, slotsForDate);
        if (daySlots.length > 0) {
          const mergedSlots = DateTimeUtils.mergeContinuousSlots(daySlots);
          availableSlots.push({
            date: DateTimeUtils.formatDate(date),
            dateFormatted: DateTimeUtils.formatDisplayDate(date),
            slots: mergedSlots,
            totalSlots: mergedSlots.length,
            totalMinutes: mergedSlots.reduce((sum, slot) => {
              const start = dayjs(`2000-01-01 ${slot.startTime}`);
              const end = dayjs(`2000-01-01 ${slot.endTime}`);
              return sum + end.diff(start, 'minute');
            }, 0)
          });
        }
      });
      Logger.endPerformanceTimer('calculate_slots');
      Logger.info(`Available slots calculated for ${availableSlots.length} days`);
      return availableSlots;
    } catch (error) {
      Logger.endPerformanceTimer('calculate_slots');
      Logger.error('Failed to calculate available slots', error);
      throw error;
    }
  },

  /**
   * 1Êó•„ÅÆÁ©∫„ÅçÊôÇÈñìË®àÁÆóÔºàÂ∏åÊúõÊôÇÈñìÂ∏Ø„Éô„Éº„ÇπÂØæÂøúÔºâ
   */
  calculateDayAvailableSlots(events, date, slotsForDate) {
    console.log('=== calculateDayAvailableSlots: Â∏åÊúõÊó•:', date.format('YYYY-MM-DD'), 'Â∏åÊúõÊôÇÈñìÂ∏Ø:', slotsForDate);
    // „Åù„ÅÆÊó•„ÅÆ‰∫àÂÆö„ÇíÊäΩÂá∫„Éª„ÇΩ„Éº„ÉàÔºàÁµÇÊó•„Ç§„Éô„É≥„Éà„ÇÇËÄÉÊÖÆÔºâ
    const dayEvents = events
      .filter(event => {
        const targetDate = date.format('YYYY-MM-DD');
        // ÁµÇÊó•„Ç§„Éô„É≥„Éà
        if (event.start?.date) {
          return event.start.date === targetDate;
        }
        // ÈÄöÂ∏∏„Ç§„Éô„É≥„ÉàÔºàÊó•‰ªòÈÉ®ÂàÜ„Å†„Åë„ÅßÊØîËºÉÔºâ
        if (event.start?.dateTime) {
          const eventDate = event.start.dateTime.split('T')[0];
          return eventDate === targetDate;
        }
        return false;
      })
      .map(event => {
        if (event.start?.date && event.end?.date) {
          // ÁµÇÊó•„Ç§„Éô„É≥„ÉàÔºàGoogle„Ç´„É¨„É≥„ÉÄ„Éº„ÅÆ‰ªïÊßò„Åßend.date„ÅØÁøåÊó•„Å´„Å™„Çã„Åì„Å®„ÅåÂ§ö„ÅÑÔºâ
          const start = dayjs(event.start.date).startOf('day');
          const end = dayjs(event.end.date).subtract(1, 'day').endOf('day');
          return { start, end };
        } else {
          // ÈÄöÂ∏∏„Ç§„Éô„É≥„Éà
          return {
            start: dayjs(event.start.dateTime).subtract(TIME_CONSTANTS.BUFFER_TIME_MINUTES, 'minute'),
            end: dayjs(event.end.dateTime).add(TIME_CONSTANTS.BUFFER_TIME_MINUTES, 'minute')
          };
        }
      })
      .sort((a, b) => a.start.diff(b.start));
    console.log('=== dayEvents for', date.format('YYYY-MM-DD'), '===', dayEvents);

    // Â∏åÊúõÊôÇÈñìÂ∏Ø„Åå„Å™„Åë„Çå„Å∞„Ç≥„Ç¢„Çø„Ç§„É†ÂÖ®‰Ωì
    const slotRanges = (slotsForDate.length > 0)
      ? slotsForDate.map(slot => ({
          start: dayjs(`${date.format('YYYY-MM-DD')}T${slot.start}`),
          end: dayjs(`${date.format('YYYY-MM-DD')}T${slot.end}`)
        }))
      : [{
          start: date.hour(TIME_CONSTANTS.CORE_TIME_START_HOUR).minute(0).second(0),
          end: date.hour(TIME_CONSTANTS.CORE_TIME_END_HOUR).minute(0).second(0)
        }];

    // ÂêÑÂ∏åÊúõÊôÇÈñìÂ∏Ø„Åî„Å®„Å´Á©∫„ÅçÊôÇÈñì„ÇíË®àÁÆó
    const slots = [];
    for (const range of slotRanges) {
      let currentTime = range.start;
      // ‰∫àÂÆö„ÅßÂüã„Åæ„Å£„Å¶„ÅÑ„Å™„ÅÑÈÉ®ÂàÜ„ÇíÁ©∫„Åç„Å®„Åó„Å¶ÊäΩÂá∫
      for (const event of dayEvents) {
        if (event.end.isBefore(currentTime)) continue;
        if (event.start.isAfter(range.end)) break;
        if (currentTime.isBefore(event.start)) {
          const slotEnd = event.start.isBefore(range.end) ? event.start : range.end;
          if (slotEnd.diff(currentTime, 'minute') >= TIME_CONSTANTS.MIN_SLOT_DURATION) {
            slots.push({
              startTime: currentTime.format('HH:mm'),
              endTime: slotEnd.format('HH:mm')
            });
          }
        }
        currentTime = event.end.isAfter(currentTime) ? event.end : currentTime;
        if (currentTime.isAfter(range.end)) break;
      }
      // ÊúÄÂæå„ÅÆ‰∫àÂÆö‰ª•Èôç„ÅÆÁ©∫„Åç
      if (currentTime.isBefore(range.end)) {
        if (range.end.diff(currentTime, 'minute') >= TIME_CONSTANTS.MIN_SLOT_DURATION) {
          slots.push({
            startTime: currentTime.format('HH:mm'),
            endTime: range.end.format('HH:mm')
          });
        }
      }
    }
    return slots;
  }
};

function loadGoogleScript() {
  if (document.getElementById('google-apis')) return;
  const script = document.createElement('script');
  script.src = 'https://accounts.google.com/gsi/client';
  script.async = true;
  script.id = 'google-apis';
  document.body.appendChild(script);
}

/**
 * „É°„Ç§„É≥„Ç¢„Éó„É™„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÔºàÂÆåÂÖ®„É™„Éï„Ç°„ÇØ„Çø„É™„É≥„Ç∞ÁâàÔºâ
 */
function CalendarGapTimeApp() {
  const [startDate, setStartDate] = useState(dayjs().format('YYYY-MM-DD'));
  const [endDate, setEndDate] = useState(dayjs().add(6, 'day').format('YYYY-MM-DD'));
  const [timeSlot, setTimeSlot] = useState({ date: '', start: '10:00', end: '22:00' });
  const [timeSlots, setTimeSlots] = useState([]);
  const [searchResult, setSearchResult] = useState(null);
  const [googleToken, setGoogleToken] = useState(null);

  // 10ÂàÜÂàª„Åø„ÅÆÊôÇÂàª„É™„Çπ„ÉàÁîüÊàêÔºà‰æã: 00:00, 00:10, ... 23:50Ôºâ
  const timeOptions = useMemo(() => {
    const options = [];
    for (let h = 0; h < 24; h++) {
      for (let m = 0; m < 60; m += 10) {
        const hh = h.toString().padStart(2, '0');
        const mm = m.toString().padStart(2, '0');
        options.push(`${hh}:${mm}`);
      }
    }
    return options;
  }, []);

  // GoogleË™çË®º„Éï„É≠„ÉºÊú¨ÂÆüË£Ö
  const handleGoogleLogin = useCallback(() => {
    const { clientId } = getConfig();
    loadGoogleScript();
    if (!window.google || !window.google.accounts || !window.google.accounts.oauth2) {
      setTimeout(handleGoogleLogin, 500); // „Çπ„ÇØ„É™„Éó„Éà„É≠„Éº„ÉâÂæÖ„Å°
      return;
    }
    window.google.accounts.oauth2.initTokenClient({
      client_id: clientId,
      scope: 'https://www.googleapis.com/auth/calendar.readonly',
      callback: (tokenResponse) => {
        if (tokenResponse && tokenResponse.access_token) {
          setGoogleToken(tokenResponse.access_token);
        } else {
          alert('GoogleË™çË®º„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
        }
      },
    }).requestAccessToken();
  }, []);

  const handleSearch = useCallback(async () => {
    console.log('Ê§úÁ¥¢„Éú„Çø„É≥„ÅåÊäº„Åï„Çå„Åæ„Åó„Åü', googleToken);
    if (!googleToken) {
      handleGoogleLogin();
      return;
    }
    try {
      let events;
      
      if (timeSlots.length > 0) {
        // Â∏åÊúõÊó•„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥ÂêàÔºöÂ∏åÊúõÊó•„Å†„Åë„ÇíÂèñÂæó
        console.log('=== Â∏åÊúõÊó•„É¢„Éº„ÉâÔºöÊåáÂÆö„Åï„Çå„ÅüÊó•‰ªò„ÅÆ„ÅøÂèñÂæó ===');
        const allEvents = [];
        
        // Â∏åÊúõÊó•„Åî„Å®„Å´ÂÄãÂà•„Å´ÂèñÂæó
        const uniqueDates = [...new Set(timeSlots.map(slot => slot.date))];
        for (const targetDate of uniqueDates) {
          console.log(`--- ${targetDate}„ÅÆ„Ç§„Éô„É≥„Éà„ÇíÂèñÂæó‰∏≠ ---`);
          const dayStart = dayjs(targetDate).startOf('day');
          const dayEnd = dayjs(targetDate).endOf('day');
          const dayEvents = await CalendarService.fetchAllCalendarEvents(googleToken, dayStart, dayEnd);
          allEvents.push(...dayEvents);
        }
        
        events = allEvents;
        console.log(`=== Â∏åÊúõÊó•„ÅÆ„Ç§„Éô„É≥„ÉàÂèñÂæóÂÆå‰∫ÜÔºö${events.length}‰ª∂ ===`);
        
      } else {
        // Â∏åÊúõÊó•„Åå„Å™„ÅÑÂ†¥ÂêàÔºöÊúüÈñìÂÖ®‰Ωì„ÇíÂèñÂæó
        console.log('=== ÊúüÈñìÂÖ®‰Ωì„É¢„Éº„ÉâÔºöstartDate„ÄúendDate„ÇíÂèñÂæó ===');
        events = await CalendarService.fetchAllCalendarEvents(googleToken, dayjs(startDate), dayjs(endDate));
      }
      
      console.log('=== ÂèñÂæó„Åó„ÅüeventsÊï∞ ===', events.length);
      
      // ÊúÄÂàù„ÅÆ3‰ª∂„ÇíÂÆåÂÖ®„Å´Âá∫Âäõ
      console.log('=== ÊúÄÂàù„ÅÆ3‰ª∂„ÅÆ„Ç§„Éô„É≥„ÉàË©≥Á¥∞ÔºàJSONÔºâ ===');
      events.slice(0, 3).forEach((e, idx) => {
        console.log(`Event ${idx}:`, JSON.stringify(e, null, 2));
      });
      
      // start/end„ÅÆÂÄ§„Å†„Åë„ÇíÊäΩÂá∫„Åó„Å¶Á¢∫Ë™ç
      console.log('=== ÂÖ®events„ÅÆstart/end‰∏ÄË¶ß ===');
      events.forEach((e, idx) => {
        console.log(`Event ${idx}: summary="${e.summary}", start=${JSON.stringify(e.start)}, end=${JSON.stringify(e.end)}`);
      });
      
      // Â∏åÊúõÊó•„Åî„Å®„Å´events„Çí„Éï„Ç£„É´„Çø„Åó„Å¶Âá∫Âäõ
      if (timeSlots.length > 0) {
        timeSlots.forEach(slot => {
          const targetDate = slot.date;
          console.log(`=== Â∏åÊúõÊó•(${targetDate})„Åß„Éï„Ç£„É´„Çø„É™„É≥„Ç∞ ===`);
          
          const filtered = events.filter((e, idx) => {
            // „Éá„Éê„ÉÉ„Ç∞Áî®„Å´ÂêÑ„Ç§„Éô„É≥„Éà„ÅÆÂà§ÂÆöÁµêÊûú„ÇíÂá∫Âäõ
            const eventDateFromDateTime = e.start?.dateTime ? e.start.dateTime.split('T')[0] : null;
            const eventDateFromDate = e.start?.date;
            const eventDate = eventDateFromDateTime || eventDateFromDate;
            const isMatch = eventDate === targetDate;
            
            if (idx < 3 || isMatch) { // ÊúÄÂàù„ÅÆ3‰ª∂„Åæ„Åü„ÅØ„Éû„ÉÉ„ÉÅ„Åó„ÅüÂ†¥Âêà„ÅØË©≥Á¥∞Âá∫Âäõ
              console.log(`  - "${e.summary}": eventDate=${eventDate}, targetDate=${targetDate}, match=${isMatch}`);
            }
            
            return isMatch;
          });
          console.log(`=== Â∏åÊúõÊó•(${targetDate})„ÅÆevents ===`, filtered.length, '‰ª∂');
        });
      }
      // Â∏åÊúõÊó•„ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„Çå„Å∞Â∏åÊúõÊó•„Å†„Åë„ÄÅ„Å™„Åë„Çå„Å∞Â∏åÊúõÊúüÈñìÂÖ®‰Ωì„ÇíÊ§úÁ¥¢
      let availableSlots;
      if (timeSlots.length > 0) {
        availableSlots = CalendarService.calculateAvailableSlots(events, dayjs(startDate), dayjs(endDate), timeSlots);
      } else {
        availableSlots = CalendarService.calculateAvailableSlots(events, dayjs(startDate), dayjs(endDate), []);
      }
      console.log('Á©∫„ÅçÊôÇÈñìÊó•Êï∞:', availableSlots.length, availableSlots);
      const resultList = availableSlots.map(day => ({
        date: day.date,
        dateDisplay: dayjs(day.date).format('YYYY/MM/DD (ddd)'),
        slots: day.slots
      }));
      setSearchResult(resultList);
    } catch (e) {
      alert('Google„Ç´„É¨„É≥„ÉÄ„Éº„Åã„Çâ‰∫àÂÆö„ÅÆÂèñÂæó„Åæ„Åü„ÅØÁ©∫„ÅçÊôÇÈñìË®àÁÆó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + (e.message || e));
      setSearchResult([]);
      console.error(e);
    }
  }, [startDate, endDate, timeSlots, googleToken, handleGoogleLogin]);

  // Â∏åÊúõÊôÇÈñìÂ∏Ø„ÇíÊó•‰ªò„Åî„Å®„Å´„Ç∞„É´„Éº„ÉóÂåñ
  const groupedTimeSlots = useMemo(() => {
    const map = {};
    timeSlots.forEach(slot => {
      if (!map[slot.date]) map[slot.date] = [];
      map[slot.date].push(`${slot.start}„Äú${slot.end}`);
    });
    return map;
  }, [timeSlots]);

  // Â∏åÊúõÊúüÈñì„ÅÆÊó•‰ªò„É™„Çπ„Éà„ÇíÁîüÊàêÔºà1ÈÄ±Èñì„Åî„Å®„Å´ÂàÜÂâ≤Ôºâ
  const weekDateList = useMemo(() => {
    const list = [];
    let d = dayjs(startDate);
    const end = dayjs(endDate);
    let week = [];
    while (d.isSameOrBefore(end, 'day')) {
      week.push(d.format('YYYY-MM-DD'));
      if (d.day() === 6) { // ÂúüÊõú„ÅßÊîπË°å
        list.push(week);
        week = [];
      }
      d = d.add(1, 'day');
    }
    if (week.length > 0) list.push(week);
    return list;
  }, [startDate, endDate]);

  // „Ç´„É¨„É≥„ÉÄ„Éº„ÅÆ„Ç´„Çπ„Çø„É†ÊèèÁîª
  const renderDay = (date, _selectedDates, pickersDayProps) => {
    const dStr = date.format('YYYY-MM-DD');
    const isStart = date.isSame(dayjs(startDate), 'day');
    const isEnd = date.isSame(dayjs(endDate), 'day');
    const inRange = date.isAfter(dayjs(startDate).subtract(1, 'day')) && date.isBefore(dayjs(endDate).add(1, 'day'));
    const hasTimeSlot = groupedTimeSlots[dStr];

    let backgroundColor = undefined;
    let color = undefined;
    let borderRadius = undefined;

    if (hasTimeSlot) {
      backgroundColor = '#1976d2';
      color = '#fff';
      borderRadius = '50%';
    } else if (inRange) {
      backgroundColor = '#e3f2fd';
      color = '#1976d2';
      // Â∏Ø„ÅÆÁ´Ø„Å†„ÅëËßí‰∏∏
      if (isStart && isEnd) {
        borderRadius = '16px';
      } else if (isStart) {
        borderRadius = '16px 0 0 16px';
      } else if (isEnd) {
        borderRadius = '0 16px 16px 0';
      } else {
        borderRadius = '0';
      }
    }

    return (
      <PickersDay
        {...pickersDayProps}
        sx={{
          backgroundColor,
          color,
          borderRadius,
          border: hasTimeSlot ? '2px solid #1976d2' : undefined,
        }}
        disableMargin
      />
    );
  };

  return (
    <Container maxWidth="sm" sx={{ background: '#fff', minHeight: '100vh', py: 4 }}>
      <Typography variant="h4" component="h1" fontWeight={700} gutterBottom>
        üóìÔ∏è „Ç´„É¨„É≥„ÉÄ„ÉºÁ©∫„ÅçÊôÇÈñìÊ§úÁ¥¢
      </Typography>
      <Typography variant="subtitle1" gutterBottom fontWeight={600}>
        Â∏åÊúõÊúüÈñì
      </Typography>
      <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
        <TextField
          label="ÈñãÂßãÊó•"
          type="date"
          value={startDate}
          onChange={e => setStartDate(e.target.value)}
          InputLabelProps={{ shrink: true }}
        />
        <TextField
          label="ÁµÇ‰∫ÜÊó•"
          type="date"
          value={endDate}
          onChange={e => setEndDate(e.target.value)}
          InputLabelProps={{ shrink: true }}
        />
      </Box>

      <Typography variant="subtitle1" gutterBottom fontWeight={600}>
        Â∏åÊúõÊôÇÈñìÂ∏Ø„ÅÆËøΩÂä†
      </Typography>
      <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
        <TextField
          label="Êó•‰ªò"
          type="date"
          value={timeSlot.date}
          onChange={e => setTimeSlot({ ...timeSlot, date: e.target.value })}
          InputLabelProps={{ shrink: true }}
        />
        <TextField
          label="ÈñãÂßãÊôÇÂàª"
          select
          value={timeSlot.start}
          onChange={e => setTimeSlot({ ...timeSlot, start: e.target.value })}
          InputLabelProps={{ shrink: true }}
          SelectProps={{ native: true }}
        >
          <option value=""></option>
          {timeOptions.map(opt => (
            <option key={opt} value={opt}>{opt}</option>
          ))}
        </TextField>
        <TextField
          label="ÁµÇ‰∫ÜÊôÇÂàª"
          select
          value={timeSlot.end}
          onChange={e => setTimeSlot({ ...timeSlot, end: e.target.value })}
          InputLabelProps={{ shrink: true }}
          SelectProps={{ native: true }}
        >
          <option value=""></option>
          {timeOptions.map(opt => (
            <option key={opt} value={opt}>{opt}</option>
          ))}
        </TextField>
        <Button
          variant="contained"
          onClick={() => {
            if (timeSlot.date && timeSlot.start && timeSlot.end) {
              setTimeSlots([...timeSlots, timeSlot]);
              setTimeSlot({ date: '', start: '10:00', end: '22:00' });
            }
          }}
        >
          ËøΩÂä†
        </Button>
      </Box>
      {/* Â∏åÊúõÊôÇÈñìÂ∏Ø„É™„Çπ„ÉàÔºàË¶ã„ÇÑ„Åô„ÅÑ„Ç´„Éº„ÉâUI„Å´ÊîπÂñÑÔºâ */}
      <List sx={{ mb: 2 }}>
        {timeSlots.map((slot, idx) => (
          <Card key={idx} variant="outlined" sx={{ mb: 1, p: 1, display: 'flex', alignItems: 'center', boxShadow: 1 }}>
            <Box sx={{ flexGrow: 1, display: 'flex', alignItems: 'center', gap: 2 }}>
              <Typography variant="body1" fontWeight={600}>
                {dayjs(slot.date).format('YYYY/MM/DD (ddd)')}
              </Typography>
              <Chip label={`${slot.start}„Äú${slot.end}`} color="primary" sx={{ fontWeight: 600, fontSize: '1rem' }} />
            </Box>
            <IconButton edge="end" aria-label="delete" onClick={() => setTimeSlots(timeSlots.filter((_, i) => i !== idx))}>
              <DeleteIcon />
            </IconButton>
          </Card>
        ))}
      </List>
      <Box sx={{ mt: 3, textAlign: 'center' }}>
        <Button
          variant="contained"
          color="primary"
          size="large"
          startIcon={<SearchIcon />}
          onClick={handleSearch}
        >
          Á©∫„ÅçÊôÇÈñì„ÇíÊ§úÁ¥¢
        </Button>
      </Box>
      {searchResult !== null && (
        <Box sx={{ mt: 3 }}>
          <Typography variant="h6" color="primary" align="center">
            Ê§úÁ¥¢ÁµêÊûú
          </Typography>
          <Box sx={{ mt: 1, textAlign: 'center' }}>
            <Typography variant="body2" color="textSecondary">
              Ê§úÁ¥¢Êù°‰ª∂Ôºö{startDate}„Äú{endDate}
            </Typography>
            {timeSlots.length > 0 ? (
              <Box sx={{ display: 'inline-block', mt: 1, textAlign: 'left' }}>
                <Typography variant="body2" color="textSecondary" fontWeight={600}>
                  Â∏åÊúõÊôÇÈñìÂ∏ØÔºö
                </Typography>
                {Object.entries(groupedTimeSlots).map(([date, times]) => (
                  <Typography key={date} variant="body2" color="textSecondary" sx={{ ml: 2 }}>
                    {dayjs(date).format('YYYY/MM/DD (ddd)')}Ôºö{times.join(' / ')}
                  </Typography>
                ))}
              </Box>
            ) : (
              <Typography variant="body2" color="textSecondary">
                Â∏åÊúõÊôÇÈñìÂ∏ØÔºöÊåáÂÆö„Å™„ÅóÔºà10:00„Äú22:00Ôºâ
              </Typography>
            )}
          </Box>
          {/* Á©∫„ÅçÊôÇÈñì„É™„Çπ„Éà„Ç¢„ÉÉ„ÉóÔºàMUI Card/List„ÅßÊó•‰ªò„ÉªÊõúÊó•„ÉªÂ∏åÊúõÊôÇÈñìÂ∏Ø„Åî„Å®„Å´„Ç∞„É´„Éº„ÉóÂåñÔºâ */}
          <Box sx={{ mt: 2, textAlign: 'left', maxWidth: 500, mx: 'auto' }}>
            <Typography variant="subtitle2" fontWeight={600} sx={{ mb: 1 }}>
              Ë¶ã„Å§„Åã„Å£„ÅüÁ©∫„ÅçÊôÇÈñì„É™„Çπ„Éà
            </Typography>
            {searchResult.length === 0 ? (
              <Typography color="textSecondary">Á©∫„ÅçÊôÇÈñì„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ</Typography>
            ) : (
              <List>
                {searchResult.map(({ date, dateDisplay, slots }) => (
                  <Card key={date} variant="outlined" sx={{ mb: 2, background: '#f8fafc' }}>
                    <CardContent>
                      <Typography variant="subtitle1" fontWeight={700}>
                        {dateDisplay}
                      </Typography>
                      {slots.length === 0 ? (
                        <Typography color="textSecondary" sx={{ ml: 2 }}>
                          ÔºàÁ©∫„ÅçÊôÇÈñì„Å™„ÅóÔºâ
                        </Typography>
                      ) : (
                        <List dense>
                          {slots.map((slot, idx) => (
                            <ListItem key={idx} sx={{ pl: 2 }}>
                              <Chip label={`${slot.startTime}„Äú${slot.endTime}`} color="primary" variant="outlined" sx={{ fontWeight: 600, fontSize: '1rem' }} />
                            </ListItem>
                          ))}
                        </List>
                      )}
                    </CardContent>
                  </Card>
                ))}
              </List>
            )}
          </Box>
        </Box>
      )}
    </Container>
  );
}

export default CalendarGapTimeApp; 